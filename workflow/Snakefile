from snakemake.utils import min_version

min_version("7.17.0")

configfile: "config/config.yaml"

import pandas as pd
import subprocess
import os, yaml
from Bio import SeqIO
import os
import shutil
import numpy as np

#---------------------------------------------
def slidingWindow(alignment_output, win=0, step=0):
    #check whether the path exist or not
    window_dir = "./results/windows/"
    isExist = os.path.isdir(window_dir)
    if not isExist:
        os.mkdir(window_dir)
    else:
        shutil.rmtree(window_dir)
        os.mkdir(window_dir)
    
    # Check if mutation happens
    windows_mutation = []

    nt = [list(str(seq_record.seq)) for seq_record in SeqIO.parse(alignment_output, "fasta")]
    seqDF = pd.DataFrame(nt)
    seqlen = seqDF.shape[1]
    for i in range(0,seqlen,step):
        j = seqlen if i+win>seqlen else i+win
        window = seqDF.iloc[:,i:j]
        window = window.replace('-', np.nan)
        window = window.dropna(axis = 0, how = 'all')
        distinctDF = window.drop_duplicates()
        #mutation happens
        if distinctDF.shape[0] > 1: 
            #print(distinctDF.shape[0])
            #print("mutation window detected: {}_{}".format(i,j))
            windows_mutation.append((i,j))
            #print(i,j)
        if j==seqlen: break
    # write the sequence of sliding window which have mutation detected in fasta file
    for seq_record in SeqIO.parse(alignment_output, "fasta"):
        for start, end in windows_mutation:
            #print(start,end)
            records = seq_record[start:end]
            with open("results/windows/window_position_" + str(start) + "_" + str(end) + ".fa", "a") as handle:
                SeqIO.write(records, handle, "fasta") 
    
   
    

#----------------------------------------------------
if not os.path.exists("results/RAxML"):
    os.makedirs("results/RAxML")
#-------------------------------
# global variable to use
file_name = config['params']['geo_file']
specimen_id = config['params']['specimen_id']
df_geo = pd.read_csv(file_name)
feature_names = list(df_geo.columns)[1:]

alignment_output = config['params']['seq_file']
window_size = config['params']['window_size']
step_size = config['params']['step_size']

#---------------------------------------------
# step 1a: Sliding windows
slidingWindow(alignment_output, window_size, step_size)

# step 1b: Reference trees construction
include: 'rules/refTrees1b.smk'

POS, = glob_wildcards("results/windows/window_position_{position}.fa")
#print("POS: ",POS)

# Step 2: Phylogenetic trees construction; Step3: Filtering -- Bootstrap of consensus; Step4: RF distance calculation; # Step 5: Filtering -- RF distance
include: 'rules/phyML2.smk'


#Step 6: Phylogenetic trees construction (option 1: with raxml-ng)
#include: 'rules/raxML3.smk'

#----------------------------------------------------
def get_windowedFilted(wildcards):
    with checkpoints.rf_phyML.get().output[0].open() as f:
        windows = pd.read_csv(f)["window_pos"].to_list()
        windows_filtered = list(filter(None,set(windows)))
        return expand("results/RaxBootstrap/{windows_pos}.raxmlBootstrap", windows_pos=windows_filtered)



rule all:
    input: get_windowedFilted


checkpoint rf_phyML: 
   input: expand("results/rf/{position}.{feature}.rf_ete", position = POS, feature=feature_names)
   output: "results/rf_phyML.csv"
   script: "scripts/rfAfterPhyML.py"


rule cp_windows:
    input:  "results/windows/window_position_{windows_pos}.fa"
    output: "results/windows_filtered/window_position_{windows_pos}.fa"
    shell: "cp {input} {output}"

rule runRaxML:
    input:  "results/windows_filtered/window_position_{windows_pos}.fa"
    output: 
            temp("results/RAxML/{windows_pos}.raxml.bestModel"),
            "results/RAxML/{windows_pos}.raxml.bestTree",
            "results/RAxML/{windows_pos}.raxml.bootstraps",
            temp("results/RAxML/{windows_pos}.raxml.log"),
            temp("results/RAxML/{windows_pos}.raxml.mlTrees"),
            temp("results/RAxML/{windows_pos}.raxml.rba"),
            temp("results/RAxML/{windows_pos}.raxml.startTree"),
            temp("results/RAxML/{windows_pos}.raxml.support"),
    run:
        os.system("raxml-ng --all --model GTR+G --msa " + input[0] + " --prefix results/RaxMl/" + wildcards.windows_pos + " --msa-format FASTA --data-type DNA --tree pars{5} --seed 239 --threads 2 --force --bs-trees 100 --bs-metric fbp")

rule bootstrapFilter2:
    input: "results/RAxML/{windows_pos}.raxml.bestTree"
    output: "results/RaxBootstrap/{windows_pos}.raxmlBootstrap"
    script:
        "scripts/RaxFilterBootstrap.py"
   
#------------------------------------------------------------

  